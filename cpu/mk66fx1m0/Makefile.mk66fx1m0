#+-------------------------------------------------------------------------------------------------+
#| Kinetis MK66FX1M0 cpu makefile.                                                                 |
#|                                                                                                 |
#| Author: Joksan Alvarado.                                                                        |
#+-------------------------------------------------------------------------------------------------+

#Set the toolchain program names.
CC = arm-none-eabi-gcc
AR = arm-none-eabi-ar
AS = arm-none-eabi-as
LD = arm-none-eabi-ld
OBJCOPY = arm-none-eabi-objcopy

#Set the processor related flags (common to C code and linker).
CPUFLAGS += -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16
CPUFLAGS += -specs=nano.specs -specs=nosys.specs

#Set the C code flags.
CFLAGS += -DMK66FX1M0
CFLAGS += -g -ffunction-sections -fdata-sections -O2
#CFLAGS += -Wall -g -ffunction-sections -fdata-sections -O2
CFLAGS += $(CPUFLAGS)

#Set the linker flags.
LDFLAGS += -Wl,--gc-sections -T$(CONTIKI_CPU)/mk66fx1m0.ld -lc
LDFLAGS += $(CPUFLAGS)

#Configure the CPU path and source files.
CONTIKI_CPU_DIRS += . hal dev ../kinetis-common/dev ../../contiki/cpu/arm/common/CMSIS
CONTIKI_SOURCEFILES += mk66-startup.c clock.c uart.c

#Don't treat %.co and $(OBJECTDIR)/syscalls.o as intermediates (avoids deletion and re-compiling)
.PRECIOUS: %.co
.PRECIOUS: $(OBJECTDIR)/syscalls.o

#Override the link rule so gcc can be called with -specs instead of ld and also generate a .hex file
#in the same process.
CUSTOM_RULE_LINK = 1
%.$(TARGET): %.co $(PROJECT_OBJECTFILES) $(PROJECT_LIBRARIES) contiki-$(TARGET).a $(OBJECTDIR)/syscalls.o
	$(TRACE_LD)
	$(Q)$(CC) $(LDFLAGS) $(TARGET_STARTFILES) ${filter-out %.a,$^} \
	    ${filter %.a,$^} $(TARGET_LIBFILES) -o $@
	$(OBJCOPY) $@ -O ihex $@.hex

#Add a clean target dependency.
distclean: cleanhex

#Target used to clean files generated by this toolchain.
.PHONY: cleanhex
cleanhex:
	rm -f *.$(TARGET).hex
